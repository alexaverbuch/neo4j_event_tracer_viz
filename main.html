<!DOCTYPE HTML>
<html>

<head>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!--<script src="http://d3js.org/d3.v4.min.js"></script>-->
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <style>

        .node {
            cursor: pointer;
        }

        .node rect {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 3px;
        }

        .node text {
            font: 12px sans-serif;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 2px;
        }
    </style>
</head>

<body>
<div id="tester" style="width:600px;height:250px;"></div>
<input type='file' onchange='openFile(event)'><br>

<script>
    const openFile = function (event) {
        const input = event.target;
        const file = input.files[0];
        const reader = new FileReader();
        reader.onload = function (e) {
            const lines = e.target.result.split("\n");
            const events = lines.slice(1)
                .filter(function (line) {
                    return line.length !== 0
                })
                // to split row
                .map(function (line) {
                    let pipelineIndex = line.indexOf("Pipeline");
                    let lastCommaIndex = line.lastIndexOf(",", pipelineIndex);
                    let columns = line.substr(0, lastCommaIndex).split(",");
                    columns[columns.length] = line
                        .substr(lastCommaIndex + 1)
                        .replace("Pipeline","")
                        .replace(/Operator/g,"");
                    return columns;
                })
                // to event object
                .map(function (splitRow) {
                    return splitRowToEvent(splitRow);
                });

            function compare(a, b) {
                if (a.startTime < b.startTime)
                    return -1;
                if (a.startTime > b.startTime)
                    return 1;
                return 0;
            }

            events.sort(compare);
            const minStartTime = events[0].startTime;
            const maxStartTime = events[events.length - 1].startTime;
            makeTree(events, minStartTime, maxStartTime);
        };
        reader.readAsText(file);

        function splitRowToEvent(splitRow) {
            return {
                "id": parseInt(splitRow[0]),
                "upstreamId": parseInt(splitRow[1]),
                "queryId": splitRow[2],
                "schedulingThreadId": parseInt(splitRow[3]),
                "schedulingTime": parseInt(splitRow[4]),
                "executionThreadId": parseInt(splitRow[5]),
                "startTime": parseInt(splitRow[6]),
                "stopTime": parseInt(splitRow[7]),
                "pipeline": splitRow[8]
            }
        }

        function makeTree(events, minStartTime, maxStartTime) {

            function makeTreeData(events) {
                const reducer = function (accTreeData, event) {
                    return addChildToTopNode(accTreeData, eventToTreeNode(event));
                };
                return events.reduce(reducer, null);
            }

            function eventToTreeNode(event) {
                return {
                    "name": event.id,
                    "parent": event.upstreamId,
                    "label": event.pipeline,
                    // zero-base start times
                    "start": event.startTime - minStartTime,
                    "duration": event.stopTime - event.startTime,
                    "children": []
                }
            }

            function addChildToTopNode(eventTree, newEvent) {
                if (!eventTree) {
                    // this is the first event. it will become the tree root.
                    return newEvent
                } else {
                    // events are added to tree in order of their execution start time.
                    // this means their parent has already been added.
                    // add new event into tree.
                    return addEventToTree(eventTree, newEvent);
                }
            }

            function addEventToTree(eventTree, newEvent) {
                if (newEvent.parent === eventTree.name) {
                    // we have found the new event's upstream/parent
                    let newChildren = (!eventTree.children || eventTree.children.length === 0)
                        ? [newEvent]
                        : eventTree.children.concat([newEvent]);
                    return withUpdatedChildren(eventTree, newChildren);
                } else {
                    // this is not the new event's upstream/parent, continue searching down the tree
                    let newChildren = (!eventTree.children || eventTree.children.length === 0)
                        // this is neither the parent, nor does it have any children. do nothing.
                        ? eventTree.children
                        // this is not the parent, but maybe one of the children will be. keep looking.
                        : eventTree.children.map(function (child) {
                            return addEventToTree(child, newEvent);
                        });
                    return withUpdatedChildren(eventTree, newChildren);
                }
            }

            function withUpdatedChildren(eventTree, newChildren) {
                return {
                    "name": eventTree.name,
                    "parent": eventTree.parent,
                    "label": eventTree.label,
                    "start": eventTree.start,
                    "duration": eventTree.duration,
                    "children": newChildren
                };
            }

            const treeData = [makeTreeData(events)];

            // ************** Generate the tree diagram	 *****************
            const margin = {top: 20, left: 20};
            const width = 100000;
            const height = 1000;

            const startTimeRange = maxStartTime - minStartTime;
            const startTimeMultiplier = width / startTimeRange;

            let i = 0;
            const duration = 750;
            const root = treeData[0];

            const tree = d3.layout.tree()
                .size([height, width]);

            const diagonal = d3.svg.diagonal()
                .projection(function (d) {
                    return [d.y, d.x];
                });

            const svg = d3.select("body").append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            root.x0 = height / 2;
            root.y0 = 0;

            update(root);

            d3.select(self.frameElement).style("height", "500px");

            function update(source) {

                // Compute the new tree layout.
                const nodes = tree.nodes(root).reverse();
                const links = tree.links(nodes);

                // Normalize for fixed-depth.
                nodes.forEach(function (d) {
                    // d.y = d.depth * 180;
                    //0, 10, 1000, 100000
                    //0, 1, 3, 5
                    // parent.start
                    // parent.duration
                    // let startTimeMultiplier = Math.log(parent.duration)
                    // Math.log(d.duration) + Math.log(d.start)
                    d.y = d.start * startTimeMultiplier;
                    // TODO remove printout
                    // console.log(d)
                });

                // Update the nodes…
                const node = svg.selectAll("g.node")
                    .data(nodes, function (d) {
                        return d.id || (d.id = ++i);
                    });

                // Enter any new nodes at the parent's previous position.
                const nodeEnter = node.enter().append("g")
                    .attr("class", "node")
                    .attr("transform", function (d) {
                        return "translate(" + source.y0 + "," + source.x0 + ")";
                    })
                    .on("click", click);

                nodeEnter.append("rect")
                    .attr("width", 1e-6)
                    .attr("height", 1e-6)
                    .style("fill", function (d) {
                        return d._children ? "lightsteelblue" : "#fff";
                    });

                nodeEnter.append("text")
                    .attr("x", 5)
                    .attr("dy", ".35em")
                    .attr("text-anchor", "start")
                    .text(function (d) {
                        return d.label;
                    })
                    .style("fill-opacity", 1e-6);

                // Transition nodes to their new position.
                const nodeUpdate = node.transition()
                    .duration(duration)
                    .attr("transform", function (d) {
                        return "translate(" + d.y + "," + d.x + ")";
                    });

                const height = 20;
                nodeUpdate.select("rect")
                    .attr("width", function (d) {
                        return d.duration * startTimeMultiplier;
                    })
                    .attr("height", height)
                    .attr("y", height/-2)
                    .attr("text", function (d) {
                        return d.label;
                    })
                    .style("fill", function (d) {
                        return d._children ? "lightsteelblue" : "#fff";
                    });

                nodeUpdate.select("text")
                    .style("fill-opacity", 1);

                // Transition exiting nodes to the parent's new position.
                const nodeExit = node.exit().transition()
                    .duration(duration)
                    .attr("transform", function (d) {
                        return "translate(" + source.y + "," + source.x + ")";
                    })
                    .remove();

                nodeExit.select("rect")
                    .attr("width", 1e-6)
                    .attr("height", 1e-6);

                nodeExit.select("text")
                    .style("fill-opacity", 1e-6);

                // Update the links…
                const link = svg.selectAll("path.link")
                    .data(links, function (d) {
                        return d.target.id;
                    });

                // Enter any new links at the parent's previous position.
                link.enter().insert("path", "g")
                    .attr("class", "link")
                    .attr("d", function (d) {
                        const o = {x: source.x0, y: source.y0};
                        return diagonal({source: o, target: o});
                    });

                // Transition links to their new position.
                link.transition()
                    .duration(duration)
                    .attr("d", diagonal);

                // Transition exiting nodes to the parent's new position.
                link.exit().transition()
                    .duration(duration)
                    .attr("d", function (d) {
                        const o = {x: source.x, y: source.y};
                        return diagonal({source: o, target: o});
                    })
                    .remove();

                // Stash the old positions for transition.
                nodes.forEach(function (d) {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });
            }

            // Toggle children on click.
            function click(d) {
                if (d.children) {
                    d._children = d.children;
                    d.children = null;
                } else {
                    d.children = d._children;
                    d._children = null;
                }
                update(d);
            }

        }

        function makeSankey(events) {
            // TODO too long
            // const labels = splitRows.map(function (row) { return row[8] });
            const labels = events.map(function (event) {
                return ""
            });

            const ids = events.map(function (event) {
                return event.id
            });
            const upstreamIds = events.map(function (event) {
                return event.upstreamId
            });
            // TODO different color for different label
            const colors = events.map(function (event) {
                return "blue"
            });
            const sources = events
            // only create edges when work unit has an upstream work unit
                .filter(function (event) {
                    return event.upstreamId !== -1
                })
                .map(function (event) {
                    return ids.indexOf(event.upstreamId)
                });
            const targets = events
            // only create edges when work unit has an upstream work unit
                .filter(function (event) {
                    return event.upstreamId !== -1
                })
                .map(function (event) {
                    return ids.indexOf(event.id)
                });
            const values = events
            // only create edges when work unit has an upstream work unit
                .filter(function (event) {
                    return event.upstreamId !== -1
                })
                .map(function (event) {
                    return 1
                });

            console.log("labels = " + labels)
            console.log("ids = " + ids)
            console.log("upstreamIds = " + upstreamIds)
            console.log("colors = " + colors)
            console.log("sources = " + sources)
            console.log("targets = " + targets)
            console.log("values = " + values)

            let data = {
                type: "sankey",
                orientation: "h",
                node: {
                    pad: 15,
                    thickness: 30,
                    line: {
                        color: "black",
                        width: 0.5
                    },
                    label: labels,
                    color: colors
                },

                link: {
                    source: sources,
                    target: targets,
                    value: values
                }
            };

            data = [data];

            const layout = {
                title: "WorkUnit Dependencies (only shows last ReducePipe dependency)",
                font: {
                    size: 10
                }
            };

            const TESTER = document.getElementById('tester');
            // Plotly.react('myDiv', data, layout)
            Plotly.react(TESTER, data, layout)
        }
    };
</script>

</body>

</html>



